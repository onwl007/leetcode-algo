# Golang

### 函数返回指针类型是安全的吗？

### Golang 中如何实现单例模式

### GC 机制是怎样的？

Go 1.3 版本只是普通的标记清除算法，在进行垃圾回收时需要 STW 暂停整个程序，所以性能比较差。  
Go 1.5 版本开始使用三色标记法进行垃圾回收。  
Go 1.8 版本开始使用三色标价法 + 混合写屏障，不需要 STW 了，所以 GC 性能进一步提高。

- 三色标记法的工作过程。  
  需要维护三个集合表，白色，灰色和黑色。
  第一步：程序在第一次启动时，会将所有对象都标记为白色。  
  第二步：程序从根集合开始扫描对象，将可达对象标记为灰色，不递归往下进行查找，只是扫描第一层。  
  第三步：程序扫描灰色集合表，将灰色对象引用的可达对象，白色对象标记为灰色，并添加到灰色集合。此时将该自身灰色对象标记为黑色，并添加到黑色集合。  
  第四步：重复第三步的过程，直到将灰色集合的清空，没有灰色对象了。此时，白色集合中的白色对象为垃圾，进行垃圾回收，黑色对象为合法的对象。

- 三色标记法可能会把正常被引用的对象当成垃圾进行回收。  
  当黑色对象引用一个白色对象，该白色对象也被一个灰色对象所引用，如果这个时候灰色对象删除对该白色对象的引用，这个白色现在只被黑色对象引用，是一个合法的，正常使用的对象。根据三色标记法的工作过程，从灰色对象开始遍历，直到灰色对象为空，因为灰色对象删除了对该白色对象的引用，所以在进行 GC 时，会将该白色对象当成垃圾进行回收，但该白色对象正在被黑色对象引用，所以就造成了误删除的情况。  
  为了避免这种情况，引入了屏障的保护机制。

- 屏障机制
  为了保证三色标记法不误删除正确引用的对象，引入屏障机制来保证对象不丢失。
  - 强三色不变式
    不存在黑色对象引用到白色对象的指针
  - 弱三色不变式
    所有被黑色对象引用的白色对象都处于灰色保护状态。意思就是黑色对象引用的白色对象，还存在有灰色对象也在引用这个白色对象。
- 插入写屏障
  具体过程：在 A 对象引用 B 对象的时候，B 对象被强制标记为灰色，满足强三色不变式，因为不存在黑色对象直接引用白色对象，白色对象会被强制变成灰色。

  这种机制在栈空间中不使用，仅仅应用在堆空间对象的操作中。

  缺点：结束时需要 STW 来重新扫描栈，标记栈上引用的白色对象的存活。

- 删除写屏障
  具体操作：被删除的对象，如果自身为灰色或者白色，那么被标记为灰色，满足弱三色不变式，保护灰色对象到白色对象的路径不会断

  缺点：回收精度低，GC 开始时 STW 扫描栈来记录初始快照，这个过程会保护开始时刻的所有存活对象。

- 混合写屏障
  1.  GC 开始将栈上的对象全部扫描标记为黑色，之后不再重新扫描，无需 STW
  2.  GC 期间，任何在栈上创建的新对象，均为黑色。
  3.  被删除的对象标记为灰色。
  4.  被添加的对象标记为灰色。

### 逃逸分析

Golang 编译器会自动决定把一个变量分配在栈上还是堆上，编译器会做逃逸分析，当发现变量没有逃出函数的作用域范围，就可以分配在栈上，反之就会分配在堆上。

- 不逃逸的对象分配在栈上，则变量在用完后就会被编译器回收，从而减少 GC 的压力。
- 栈上的分配要比堆上的分配更加高效。

`go run -gcflags '-m -l' main.go`  
`-m` 会打印出逃逸分析的优化策略  
`-l` 会禁用内联函数，在这里禁用掉内联能更好的观察逃逸情况，减少干扰。

```go
package main

func foo(arg_val int) *int {
	var foo_val int = 11
	return &foo_val
}

func main() {
	main_val := foo(666)
	println(*main_val)
}
```

外部函数使用了子函数的局部变量，所以子函数的变量分配在堆上，而不是栈上，发生了变量逃逸。

Golang 中一个函数内局部变量，不管是不是动态 new 出来的，会被分配在堆上还是栈上，是由编译器做逃逸分析之后做出的决定。

发生逃逸的情况

- 指针逃逸
  在某个函数中 new 字面量创建的变量，将其指针作为函数返回值，则该变量一定发生逃逸。

- 栈空间不足逃逸
  操作系统对内核线程使用的栈空间是有大小限制的，64 位系统上通常是 8 MB，可以使用 `ulimit -a` 命令查看栈允许占用的内存大小。

  对于 Go 来说，goroutine 的初始栈大小为 2 KB，当 goroutine 被调度时，会绑定到内核线程执行，栈空间大小最大也不会超过操作系统的限制。

  当我们创建一个很大的 slice 时。

  ```go
  func main() {
  	stack()
  }

  func stack() {
  	s := make([]int, 100000, 100000)
  	s[0] = 1
  }
  ```

- interface 动态类型逃逸
  对于 `interface` 类型，编译器在编译的时候很难知道在函数的调用或者结构体的赋值过程会是什么样的类型，因此只能分配到 `堆` 上。

- 闭包

  > 一个函数和对其周围状态（词法环境）的引用捆绑在一起，这样的组合就是闭包。也就是，闭包让你可以在一个内层函数中访问到其外层函数的作用域。

  ```go
  func Increase() func() int {
  	n := 0
  	return func() int {
  		n++
  		return n
  	}
  }

  func main() {
  	in := Increase()
  	fmt.Println(in()) // 1
  	fmt.Println(in()) // 2
  }
  ```

  `Increase()` 返回值就是一个闭包函数，该闭包函数访问了外部变量 n，那变量 n 将会一直存在，直到 in 被销毁。很显然，变量 n 占用的内存不能随着函数 `Increase()` 的退出而回收，因此将会逃逸到堆上。

- 如何利用逃逸分析提升性能
  传值 VS 传指针
  传值会拷贝整个对象，而传指针只会拷贝指针地址，指向的对象是同一个。传指针可以减少值的拷贝，但是会导致内存分配逃逸到堆中，增加 GC 的负担。在对象频繁创建和删除的场景下，传递指针导致的 GC 开销可能会严重影响性能。

  一般情况下，对于需要修改原对象值，或占用内存比较大的结构体，选择传指针。对于只读的占用内存比较小的结构体，直接传值能够获得更好的性能。

### 锁的实现机制怎样的

### 怎样对切片进行扩容

append 函数

### 无缓冲通道和有缓冲通道的应用场景

### 分布式事务如何做

### Context 有哪些方法，都是干什么的

### Docker & K8s

### 协程与协程之间如何通信

1. 共享全局变量
2. channel
3. context

### sync.Map

map 在并发情况下是有安全问题的，只读是线程安全的，同时写线程不安全，所以为了并发安全和高效，官方实现了 sync.Map

并发写 map 会存在什么问题呢？

```go
func main() {
    m := map[int]int{1:1}
    go do(m)
    go do(m)

    time.Sleep(1*time.Second)
    fmt.Println(m)
}

func do(m map[int]int) {
	i := 0
	for i < 10000 {
		m[1] = 1
		i++
	}
}

// fatal error: concurrent map writes
```

低配版解决方案，加一把大锁

```go
var s sync.RWMutex

func main() {
    m := map[int]int{1: 1}
	go do(m)
	go do(m)
	time.Sleep(1 * time.Second)
	fmt.Println(m)
}

func do(m map[int]int) {
	i := 0
	for i < 10000 {
		s.Lock()
		m[1] = 1
		s.Unlock()
		i++
	}
}
```

加锁不是最优解，一般都会有效率问题，简单的说就是加锁影响其他的元素操作了。

```go
func main() {
    m := sync.Map{}
	m.Store(1, 1)
	go do(m)
	go do(m)
	time.Sleep(1 * time.Second)
	fmt.Println(m.Load(1))
}

func do(m sync.Map) {
	i := 0
	for i < 10000 {
		m.Store(1, 1)
		i++
	}
}
```

# Node.js

# Redis

# Nginx

# MongoDB

# MySQL

# gRPC
